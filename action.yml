name: 'Bump Release'
description: 'Modern changelog and release management for Bun'
author: 'SylphxAI'

branding:
  icon: 'package'
  color: 'orange'

inputs:
  mode:
    description: 'Mode: "auto" (default), "release", "version", or "pr". Auto mode creates PR on normal commits, publishes on release commits.'
    required: false
    default: 'auto'
  base-branch:
    description: 'Base branch for PR mode (default: main)'
    required: false
    default: 'main'
  dry-run:
    description: 'Preview changes without applying them'
    required: false
    default: 'false'
  github-token:
    description: 'GitHub token for creating releases'
    required: false
    default: ${{ github.token }}
  npm-token:
    description: 'NPM token for publishing packages'
    required: false
  publish:
    description: 'Publish to npm after versioning'
    required: false
    default: 'true'
  tag:
    description: 'Create git tags'
    required: false
    default: 'true'
  changelog:
    description: 'Update changelog'
    required: false
    default: 'true'
  github-release:
    description: 'Create GitHub release'
    required: false
    default: 'true'
  commit-message:
    description: 'Custom commit message for version bump'
    required: false
  working-directory:
    description: 'Working directory for the action'
    required: false
    default: '.'
  skip-install:
    description: 'Skip installing bump CLI (for dogfooding with local build)'
    required: false
    default: 'false'
  cli-path:
    description: 'Path to bump CLI (for dogfooding with local build)'
    required: false
    default: 'bump'

outputs:
  published:
    description: 'Whether packages were published'
    value: ${{ steps.bump.outputs.published }}
  version:
    description: 'The new version (for single package repos)'
    value: ${{ steps.bump.outputs.version }}
  versions:
    description: 'JSON object of package versions (for monorepos)'
    value: ${{ steps.bump.outputs.versions }}

runs:
  using: 'composite'
  steps:
    - name: Setup Bun
      uses: oven-sh/setup-bun@v2
      with:
        bun-version: latest

    - name: Install bump CLI
      if: inputs.skip-install != 'true'
      shell: bash
      run: bun add -g @sylphx/bump

    - name: Configure npm authentication
      if: inputs.npm-token != ''
      shell: bash
      run: |
        echo "//registry.npmjs.org/:_authToken=${{ inputs.npm-token }}" > ~/.npmrc

    - name: Configure git
      if: inputs.mode == 'pr' || inputs.mode == 'auto'
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Run bump
      id: bump
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        NPM_TOKEN: ${{ inputs.npm-token }}
        BUMP_CLI: ${{ inputs.cli-path }}
        COMMIT_MSG: ${{ github.event.head_commit.message }}
      run: |
        # Determine effective mode
        MODE="${{ inputs.mode }}"
        IS_RELEASE_COMMIT=false

        if [ "$MODE" = "auto" ]; then
          # workflow_dispatch has no commit message - default to publish
          if [ -z "$COMMIT_MSG" ]; then
            MODE="publish"
            echo "Auto mode: manual trigger, publishing..."
          elif [[ "$COMMIT_MSG" == chore\(release\):* ]]; then
            MODE="publish"
            IS_RELEASE_COMMIT=true
            echo "Auto mode: detected release commit, publishing directly..."
          else
            MODE="pr"
            echo "Auto mode: normal commit, creating/updating PR..."
          fi
        fi

        if [ "$MODE" = "pr" ]; then
          # PR mode - create/update release PR
          args="pr --base ${{ inputs.base-branch }}"
          if [ "${{ inputs.dry-run }}" = "true" ]; then
            args="$args --dry-run"
          fi
          echo "Running: $BUMP_CLI $args"
          $BUMP_CLI $args
          echo "published=false" >> $GITHUB_OUTPUT

        elif [ "$MODE" = "publish" ] || [ "$IS_RELEASE_COMMIT" = "true" ]; then
          # Publish mode - just publish current version, don't bump
          # Check if this is a monorepo
          WORKSPACES=$(jq -r '.workspaces // empty | .[]?' package.json 2>/dev/null)

          if [ -n "$WORKSPACES" ]; then
            # Monorepo mode - collect all package versions
            echo "Monorepo publish mode..."
            VERSIONS_JSON="{}"

            for pattern in $WORKSPACES; do
              for pkg_dir in $pattern; do
                if [ -f "$pkg_dir/package.json" ]; then
                  PKG_NAME=$(jq -r '.name' "$pkg_dir/package.json")
                  PKG_VERSION=$(jq -r '.version' "$pkg_dir/package.json")
                  PKG_PRIVATE=$(jq -r '.private // false' "$pkg_dir/package.json")

                  if [ "$PKG_PRIVATE" = "false" ]; then
                    echo "Package: $PKG_NAME@$PKG_VERSION"
                    VERSIONS_JSON=$(echo "$VERSIONS_JSON" | jq --arg name "$PKG_NAME" --arg ver "$PKG_VERSION" '. + {($name): $ver}')
                  fi
                fi
              done
            done

            echo "versions=$VERSIONS_JSON" >> $GITHUB_OUTPUT

            if [ "${{ inputs.dry-run }}" = "true" ]; then
              echo "Dry run - would publish packages"
              echo "published=false" >> $GITHUB_OUTPUT
            else
              echo "published=true" >> $GITHUB_OUTPUT
            fi
          else
            # Single package mode
            echo "Publishing current version from package.json..."
            VERSION=$(jq -r .version package.json)
            PACKAGE_NAME=$(jq -r .name package.json)
            echo "Package: $PACKAGE_NAME@$VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT

            if [ "${{ inputs.dry-run }}" = "true" ]; then
              echo "Dry run - would publish $PACKAGE_NAME@$VERSION"
              echo "published=false" >> $GITHUB_OUTPUT
            else
              # Create tag if not exists
              if [ "${{ inputs.tag }}" = "true" ]; then
                TAG="v$VERSION"
                if ! git tag -l | grep -q "^$TAG$"; then
                  echo "Creating tag $TAG..."
                  git tag -a "$TAG" -m "Release $TAG"
                  git push origin "$TAG"
                fi
              fi

              # Create GitHub release
              if [ "${{ inputs.github-release }}" = "true" ]; then
                echo "Creating GitHub release..."
                gh release create "v$VERSION" --title "v$VERSION" --generate-notes || true
              fi

              echo "published=true" >> $GITHUB_OUTPUT
            fi
          fi

        else
          # Release/version mode - run bump command
          args=""

          if [ "${{ inputs.dry-run }}" = "true" ]; then
            args="$args --dry-run"
          fi

          if [ "${{ inputs.tag }}" = "false" ]; then
            args="$args --no-tag"
          fi

          if [ "${{ inputs.changelog }}" = "false" ]; then
            args="$args --no-changelog"
          fi

          if [ "${{ inputs.github-release }}" = "false" ]; then
            args="$args --no-release"
          fi

          echo "Running: $BUMP_CLI $args"
          $BUMP_CLI $args

          # Set outputs
          if [ "${{ inputs.dry-run }}" = "false" ] && [ "${{ inputs.publish }}" = "true" ]; then
            echo "published=true" >> $GITHUB_OUTPUT
          else
            echo "published=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Install dependencies
      if: steps.bump.outputs.published == 'true' && inputs.npm-token != ''
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: bun install

    - name: Publish to npm
      if: steps.bump.outputs.published == 'true' && inputs.npm-token != ''
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        NPM_TOKEN: ${{ inputs.npm-token }}
      run: |
        # Setup npmrc
        echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc

        # Check if this is a monorepo (has workspaces)
        if [ -f "package.json" ]; then
          WORKSPACES=$(jq -r '.workspaces // empty | .[]?' package.json 2>/dev/null)

          if [ -n "$WORKSPACES" ]; then
            echo "Monorepo detected, publishing workspace packages..."

            # Find and publish each workspace package
            for pattern in $WORKSPACES; do
              # Handle glob patterns like "packages/*"
              for pkg_dir in $pattern; do
                if [ -f "$pkg_dir/package.json" ]; then
                  PKG_NAME=$(jq -r '.name' "$pkg_dir/package.json")
                  PKG_VERSION=$(jq -r '.version' "$pkg_dir/package.json")
                  PKG_PRIVATE=$(jq -r '.private // false' "$pkg_dir/package.json")

                  if [ "$PKG_PRIVATE" = "false" ]; then
                    echo "Publishing $PKG_NAME@$PKG_VERSION..."
                    cd "$pkg_dir"
                    echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc
                    bun publish --access public || true
                    rm -f .npmrc
                    cd - > /dev/null

                    # Create per-package tag if not exists
                    if [ "${{ inputs.tag }}" = "true" ]; then
                      TAG="${PKG_NAME}@${PKG_VERSION}"
                      if ! git tag -l | grep -q "^${TAG}$"; then
                        echo "Creating tag $TAG..."
                        git tag -a "$TAG" -m "Release $TAG"
                      fi
                    fi
                  else
                    echo "Skipping private package: $PKG_NAME"
                  fi
                fi
              done
            done

            # Push all tags at once
            if [ "${{ inputs.tag }}" = "true" ]; then
              git push --tags || true
            fi
          else
            # Single package mode
            echo "Publishing single package..."
            echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc
            bun publish --access public
            rm -f .npmrc
          fi
        fi

        rm -f ~/.npmrc
